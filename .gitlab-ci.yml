# == Summary of Baserow's CI workflow:
#
# This file contains the gitlab CI job definitions that build and test Baserow
# automatically.
#
# === Overview of how Baserow uses git branches
#
# * `develop` is the branch we merge newly developed features onto from feature
#   branches.
# * a feature branch is a branch made starting off `develop` containing a specific
#   new feature, when finished it will be merged back onto `develop`.
# * `master` is the branch which contains official releases of Baserow, to do so we
#   periodically merge the latest changes from `develop` onto `master` and then tag
#   that new master commit with a git tag containing the version (1.8.2 etc).
#
# === How new version of Baserow is released to Dockerhub
#
# A. Create an MR from develop to master and merge it.
# B. Wait for the merge commit pipeline succeed on master which will build and test the
#    images.
# C. Tag the merge commit in the Gitlab GUI with the git tag being the Baserow version
#    (1.8.2, 1.0, etc).
# D. Gitlab will make a new pipeline for the tag which will push the images built in
#    step B to Dockerhub. If step B failed or has not completed yet then this pipeline
#    will fail and not push anything.
#
# === What Gitlab CI steps are configured to run and when
#
# See below for the high level summary of the steps Gitlab will run to build, test and
# release Baserow images in various scenarios depending on the branches involved.
#
# ==== On the master branch - When MR Merged/commit pushed/branch made
#
#   1. The backend and web-frontend dev images will be built and pushed to the
#      gitlab ci image repo.
#      1. A `{image_dev}:ci-latest-$CI_COMMIT_SHA` image is pushed for the next stages.
#      2. A `{image_dev}:ci-latest-$BRANCH_NAME` image is pushed to cache future runs.
#   2. The pushed `ci-latest-$CI_COMMIT_SHA` images will be tested and linted. If a
#      previously successful test/lint run is found for the same/prev commit AND no
#      files have changed which could possibly change the result this is skipped.
#   3. Cached from the `ci-latest-$CI_COMMIT_SHA` image the non-dev images will be built
#      and then both the dev and non-dev images will be with tagged marking them as
#      tested and pushed to the gitlab ci repo.
#   4. Trigger a pipeline in any downstream repos that depend on this one.
#
# ==== On the develop branch - When MR Merged/new commit pushed
#
#   The build and testing steps 1, 2 and 3 from above are run first and then:
#   4. Push the tested images from step 3 to the Dockerhub repo under the
#      `develop-latest` tag.
#   5. Trigger a pipeline in any downstream repos that depend on this one.
#
# ==== On feature branches - When MR Merged/new commit pushed
#
#   The build and testing steps 1, 2 and 3 from above are run.
#
# ===== On the latest commit on master - When a Git tag is created
#
#   This is done when we have merged the latest changes from develop on master, and we
#   want to release them as a new version of Baserow. Gitlab will automatically detect
#   the new git tag and only do the following:
#
#   1. Push the images built from step 3 above (or fail if they don't exist) to the
#      Dockerhub repo with the tags:
#      1. `latest`
#      2. `${git tag}`
#
# ==== Older commit on master - When a Git tag created
#
#   1. Push the images built from step 3 above (or fail if they don't exist) to the
#      Dockerhub repo with the tags:
#      1. `${git tag}`
#
# ==== Any non-master commit - When a Git tag created
#
#   1. Fail as only master commits should be tagged/released.
#
# == Cleanup
#
# Images with tags starting with `ci-latest` or `ci-tested` (made in steps 1. and 3.)
# will be deleted after they are 7 days old by a job that runs daily at 11AM CET.

include: '/.gitlab/ci_includes/jobs.yml'

stages:
  - build
  - test
  - build-final
  - publish

variables:
  ENABLE_JOB_SKIPPING:
    value: "true"
    description: "If set to false then tests and lints will be forced to run and not use previously cached results."
  ENABLE_COVERAGE:
    value: "true"
    description: "If set to false then tests will not generate coverage or testing reports used by gitlab to show nicer MRs."
  # An image repo which is used for storing and passing images between ci pipeline jobs
  # and also speeding up ci builds by caching from the latest ci image when building.
  CI_IMAGE_REPO: $CI_REGISTRY_IMAGE/ci
  # Any images with tags prefixed with the two variables below will be cleaned up automatically
  # by our gitlab cleanup job:
  # (https://gitlab.com/bramw/baserow/-/settings/packages_and_registries).
  #
  # ## Note:
  #   These cleanup tag prefixes are needed as gitlab only supports cleanup by defining
  #   a regex that matches tags, so we can't do cleanup differently based on image name
  #   or repo...
  #
  # IMPORTANT: UPDATE GITLAB CONTAINER REPO CLEANUP JOB REGEX IF YOU CHANGE THIS
  CLEANUP_JOB_CI_TAG_PREFIX: ci-latest-
  # IMPORTANT: UPDATE GITLAB CONTAINER REPO CLEANUP JOB REGEX IF YOU CHANGE THIS
  TESTED_IMAGE_PREFIX: ci-tested-
  # An image repo where dev and normal images will be released to for public usage after
  # they have been successfully built and tested.
  RELEASE_IMAGE_REPO: $CI_REGISTRY_IMAGE/testing
  BACKEND_IMAGE_NAME: backend
  BACKEND_DEV_IMAGE_NAME: backend_dev
  WEBFRONTEND_IMAGE_NAME: web-frontend
  WEBFRONTEND_DEV_IMAGE_NAME: web-frontend_dev
  BACKEND_CI_DEV_IMAGE: $CI_IMAGE_REPO/$BACKEND_DEV_IMAGE_NAME:$CLEANUP_JOB_CI_TAG_PREFIX$CI_COMMIT_SHORT_SHA
  WEBFRONTEND_CI_DEV_IMAGE: $CI_IMAGE_REPO/$WEBFRONTEND_DEV_IMAGE_NAME:$CLEANUP_JOB_CI_TAG_PREFIX$CI_COMMIT_SHORT_SHA
  # Once images are tested they will publish under these names to ensure that any
  # tag only runs of the pipeline can never publish untested images.
  TESTED_BACKEND_CI_IMAGE: $CI_IMAGE_REPO/$BACKEND_IMAGE_NAME:$TESTED_IMAGE_PREFIX$CI_COMMIT_SHORT_SHA
  TESTED_WEBFRONTEND_CI_IMAGE: $CI_IMAGE_REPO/$WEBFRONTEND_IMAGE_NAME:$TESTED_IMAGE_PREFIX$CI_COMMIT_SHORT_SHA
  TESTED_BACKEND_CI_DEV_IMAGE: $CI_IMAGE_REPO/$BACKEND_DEV_IMAGE_NAME:$TESTED_IMAGE_PREFIX$CI_COMMIT_SHORT_SHA
  TESTED_WEBFRONTEND_CI_DEV_IMAGE: $CI_IMAGE_REPO/$WEBFRONTEND_DEV_IMAGE_NAME:$TESTED_IMAGE_PREFIX$CI_COMMIT_SHORT_SHA
  # Used to tag the latest images on $DEVELOP_BRANCH_NAME
  DEVELOP_LATEST_TAG: develop-latest
  # Names of important branches used to decide when to run certain jobs.
  MASTER_BRANCH_NAME: master
  DEVELOP_BRANCH_NAME: develop
  # The locations of the various dockerfiles to build.
  BACKEND_DOCKERFILE_PATH: $CI_PROJECT_DIR/backend/Dockerfile
  WEBFRONTEND_DOCKERFILE_PATH: $CI_PROJECT_DIR/web-frontend/Dockerfile
  # The image path for the helper CI util image that will be built and pushed to.
  CI_UTIL_IMAGE: $CI_IMAGE_REPO/ci_util_image:latest

# ==================================== CI UTIL ====================================

build-ci-util-image:
  image: docker:20.10.12
  stage: build
  services:
    - docker:20.10.12-dind
  variables:
    DOCKER_BUILDKIT: 1
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
  before_script:
    - |
      echo "$CI_REGISTRY_PASSWORD" | \
        docker login -u "$CI_REGISTRY_USER" "$CI_REGISTRY" --password-stdin
  script:
    - cd .gitlab/ci_util_image
    - docker build -t $CI_UTIL_IMAGE .
    - docker push $CI_UTIL_IMAGE
  # Only trigger this job manually to prevent it running every single time a new branch
  # is made. See https://gitlab.com/gitlab-org/gitlab/-/issues/11427
  when:
    manual
  # We can't use the newer rules: syntax due to https://gitlab.com/gitlab-org/gitlab/-/issues/34756
  only:
    changes:
      - .gitlab/ci_util_image/*
  except:
    refs:
      # When a pipeline is triggered by an upstream project we don't want to rebuild.
      - pipelines
      # When a pipeline is triggered by a git commit tag we don't want to rebuild.
      - tags

# ==================================== BACKEND ====================================

# If pipeline not triggered by tag :
# - Builds the backend dev image and stores in ci repo for next stages.
build-backend-image:
  extends: .build-baserow-image
  variables:
    DEV_IMAGE_NAME: $BACKEND_DEV_IMAGE_NAME
    DOCKERFILE_PATH: $BACKEND_DOCKERFILE_PATH

# If pipeline not triggered by tag:
# - Runs the backend lint if changes to the backend, otherwise skips.
backend-lint:
  extends:
    - .docker-image-test-stage
    - .skippable-job
  variables:
    RUN_WHEN_CHANGES_TO: "backend/ premium/backend/"
  script:
    - docker run --rm $BACKEND_CI_DEV_IMAGE lint

# If pipeline not triggered by tag:
# - Runs the backend startup check if changes to the backend, otherwise skips.
backend-check-startup:
  extends:
    - .docker-image-test-stage
    - .skippable-job
  services:
    - docker:20.10.12-dind
    - name: postgres:11.3
      alias: db
  variables:
    RUN_WHEN_CHANGES_TO: "backend/ premium/backend/"
  script:
    - DB_IP=$(cat /etc/hosts | awk '{if ($2 == "db") print $1;}')
    - ping -w 2 $DB_IP
    - |
      docker run -e DATABASE_USER=baserow \
          -e DATABASE_NAME=baserow \
          -e DATABASE_HOST=db \
          -e DATABASE_PASSWORD=baserow \
          --rm \
          --add-host="db:$DB_IP" \
          $BACKEND_CI_DEV_IMAGE ci-check-startup;

# If pipeline not triggered by tag:
# - Runs the backend tests (the first 1/3) if changes to the backend, otherwise skips.
# - Generates coverage db's and stores as artifact for later coverage merge and report
backend-test-group-1:
  extends:
    - .docker-image-test-stage
    - .skippable-job
  services:
    - docker:20.10.12-dind
    - name: postgres:11.3
      alias: db
    - name: liminspace/mjml-tcpserver:0.10
      alias: mjml
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
    POSTGRES_USER: baserow
    POSTGRES_PASSWORD: baserow
    POSTGRES_DB: baserow
    PYTEST_SPLIT_GROUP: 1
    RUN_WHEN_CHANGES_TO: "backend/ premium/backend/"
    DOWNLOAD_AND_UNPACK_ARTIFACTS_ON_SKIP: 'true'
  script:
    - MJML_IP=$(cat /etc/hosts | awk '{if ($2 == "mjml") print $1;}')
    - ping -w 2 $MJML_IP
    - DB_IP=$(cat /etc/hosts | awk '{if ($2 == "db") print $1;}')
    - ping -w 2 $DB_IP
    - mkdir -p reports
    - TEST_TYPE=$([[ "$ENABLE_COVERAGE" = "true" ]] && echo "ci-test" || echo "test")
    - |
      docker run \
        -e PYTEST_SPLITS=3 \
        -e PYTEST_SPLIT_GROUP=$PYTEST_SPLIT_GROUP \
        --name=baserow_backend_test_container \
        --add-host="db:$DB_IP" \
        --add-host="mjml:$MJML_IP" \
        $BACKEND_CI_DEV_IMAGE $TEST_TYPE;
    - docker cp baserow_backend_test_container:/baserow/backend/reports .
    - docker rm baserow_backend_test_container
    - |
      if [[ $PYTEST_SPLIT_GROUP = 1 ]]; then
        docker run -e DATABASE_USER=baserow \
          -e DATABASE_NAME=baserow \
          -e DATABASE_HOST=db \
          -e DATABASE_PASSWORD=baserow \
          --rm \
          --add-host="db:$DB_IP" \
          --add-host="mjml:$MJML_IP" \
          $BACKEND_CI_DEV_IMAGE ci-check-startup;
      fi
  artifacts:
    paths:
      - reports/
    reports:
      junit: reports/report.xml

# Create 2 more separate groups to parallelize pytest by using separate groups to
# decrease overall build time. Pytest xdist doesn't help as the gitlab saas runners only
# have a single virtual core so `pytest -n 2+` slows things down.
backend-test-group-2:
  extends: backend-test-group-1
  variables:
    PYTEST_SPLIT_GROUP: 2

backend-test-group-3:
  extends: backend-test-group-1
  variables:
    PYTEST_SPLIT_GROUP: 3

# Collects together all the separate backend coverage databases from previous jobs and
# combines them to generate a single report for gitlab to use. Gitlab itself does not
# correctly merge these if you just add them all separately into artifacts->reports->
# cobertura.
collect-backend-coverage:
  image: $CI_UTIL_IMAGE
  stage: build-final
  interruptible: true
  only:
    variables:
      - $ENABLE_COVERAGE == "true"
  # Prevent rebuilds when tagging as all we want to do is tag and push
  except:
    variables:
      - $CI_COMMIT_TAG
  # Depend on the `reports` artifacts from the previous jobs
  dependencies:
    - backend-test-group-1
    - backend-test-group-2
    - backend-test-group-3
  script:
    - . /baserow/venv/bin/activate
    # The reports artifacts will be extracted before the script runs into reports by
    # gitlab
    - cp reports/.coverage.* .
    - export COVERAGE_RCFILE=backend/.coveragerc
    - coverage combine
    - coverage report
    - coverage xml -o coverage.xml
  artifacts:
    reports:
      cobertura: coverage.xml
  coverage: '/^TOTAL.+?(\d+\%)$/'

# If pipeline not triggered by tag:
# - Build and store non-dev images in CI repo under the `ci-tested` tag so we know
#   those images have passed the tests.
build-final-backend-image:
  extends: .build-final-baserow-image
  variables:
    IMAGE_NAME: $BACKEND_IMAGE_NAME
    DEV_IMAGE_NAME: $BACKEND_DEV_IMAGE_NAME
    DOCKERFILE_PATH: $BACKEND_DOCKERFILE_PATH

# ==================================== WEB-FRONTEND ====================================

# If pipeline not triggered by tag:
# - Builds the web-frontend dev image and stores in ci repo for next stages.
build-web-frontend-image:
  extends: .build-baserow-image
  variables:
    DEV_IMAGE_NAME: $WEBFRONTEND_DEV_IMAGE_NAME
    DOCKERFILE_PATH: $WEBFRONTEND_DOCKERFILE_PATH

# If pipeline not triggered by tag:
# - Runs eslint and stylelint if the web-frontend code has changed, otherwise skips.
web-frontend-lint:
  extends:
    - .docker-image-test-stage
    - .skippable-job
  variables:
    RUN_WHEN_CHANGES_TO: "web-frontend/ premium/web-frontend/"
  script:
    - docker run --rm $WEBFRONTEND_CI_DEV_IMAGE lint

# If pipeline not triggered by tag:
# - Runs the web-frontend tests if the web-frontend has changed, otherwise skips.
# - Generates coverage and testing reports
web-frontend-test:
  extends:
    - .docker-image-test-stage
    - .skippable-job
  variables:
    RUN_WHEN_CHANGES_TO: "web-frontend/ premium/web-frontend/"
    DOWNLOAD_AND_UNPACK_ARTIFACTS_ON_SKIP: 'true'
  script:
    - mkdir reports/ -p
    - TEST_TYPE=$([[ "$ENABLE_COVERAGE" = "true" ]] && echo "ci-test" || echo "test")
    - |
      docker run --name=webfrontend_test $WEBFRONTEND_CI_DEV_IMAGE $TEST_TYPE \
        | tee reports/stdout.txt;
    - docker cp webfrontend_test:/baserow/reports .
    - docker rm webfrontend_test
  artifacts:
    paths:
      - reports/
    reports:
      cobertura: reports/coverage/cobertura-coverage.xml
      junit: reports/junit.xml
  coverage: '/Lines\s*:\s*(\d+.?\d*)%/'

# If pipeline not triggered by tag:
# - Build and store non-dev images in CI repo under the `ci-tested` tag so we know
#   those images have passed the tests.
build-final-web-frontend-image:
  extends: .build-final-baserow-image
  variables:
    IMAGE_NAME: $WEBFRONTEND_IMAGE_NAME
    DEV_IMAGE_NAME: $WEBFRONTEND_DEV_IMAGE_NAME
    DOCKERFILE_PATH: $WEBFRONTEND_DOCKERFILE_PATH
