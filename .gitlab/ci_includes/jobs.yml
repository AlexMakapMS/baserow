# ============== "Abstract" ci stages used by real stages =======================

# Builds a dev version of a specific Dockerfile (--target dev) using a previous CI
# image or the latest develop image as a cache to speed up the build. Tags and pushes
# the resulting dev image for later stages in the pipeline to use.
#
# To extend this stage set the DOCKERFILE_PATH and IMAGE_NAME variables.
.build-baserow-image:
  image: docker:20.10.12
  stage: build
  interruptible: true
  # We can't use the newer rules: syntax due to https://gitlab.com/gitlab-org/gitlab/-/issues/34756
  except:
    refs:
      # When a pipeline is triggered by an upstream project we don't want to rebuild.
      - pipelines
      # When a pipeline is triggered by a git commit tag we don't want to rebuild.
      - tags
  services:
    - docker:20.10.12-dind
  variables:
    DOCKER_BUILDKIT: 1
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
    IMAGE_LABELS: >
      --label org.opencontainers.image.vendor=$CI_PROJECT_URL
      --label org.opencontainers.image.authors=$CI_PROJECT_URL
      --label org.opencontainers.image.revision=$CI_COMMIT_SHA
      --label org.opencontainers.image.source=$CI_PROJECT_URL
      --label org.opencontainers.image.documentation=$CI_PROJECT_URL
      --label org.opencontainers.image.licenses=$CI_PROJECT_URL
      --label org.opencontainers.image.url=$CI_PROJECT_URL
      --label vcs-url=$CI_PROJECT_URL
      --label com.gitlab.ci.user=$CI_SERVER_URL/$GITLAB_USER_LOGIN
      --label com.gitlab.ci.email=$GITLAB_USER_EMAIL
      --label com.gitlab.ci.tagorbranch=$CI_COMMIT_REF_NAME
      --label com.gitlab.ci.pipelineurl=$CI_PIPELINE_URL
      --label com.gitlab.ci.commiturl=$CI_PROJECT_URL/commit/$CI_COMMIT_SHA
      --label com.gitlab.ci.cijoburl=$CI_JOB_URL
      --label com.gitlab.ci.mrurl=$CI_PROJECT_URL/-/merge_requests/$CI_MERGE_REQUEST_ID
      --label org.opencontainers.image.ref.name=$CI_IMAGE_REPO:$CI_COMMIT_REF_NAME
  script:
    - |
      echo "$CI_REGISTRY_PASSWORD" | \
        docker login -u "$CI_REGISTRY_USER" "$CI_REGISTRY" --password-stdin
      if [[ -z "$DOCKERFILE_PATH" ]]; then
          echo "Must provide DOCKERFILE_PATH as a job variable" 2>&1
          exit 1
      fi
      if [[ -z "$DEV_IMAGE_NAME" ]]; then
          echo "Must provide DEV_IMAGE_NAME as a job variable" 2>&1
          exit 1
      fi


      # Try cache from this branches latest image, if not fall back to the latest
      # develop image.
      # Ensure we don't go over 128 char docker tag length limit
      TRUNCATED_BRANCH_NAME=${CI_COMMIT_REF_NAME:0:100}
      CI_DEV_LATEST_BRANCH_TAG=$CLEANUP_JOB_CI_TAG_PREFIX$TRUNCATED_BRANCH_NAME

      LATEST_CI_IMAGE="$CI_IMAGE_REPO/$DEV_IMAGE_NAME:$CI_DEV_LATEST_BRANCH_TAG"
      # ===== 1. Try pull an image we can use to cache the build with =====

      # First try the latest CI image for this branch
      CACHE_IMAGE=$LATEST_CI_IMAGE
      if ! docker pull $CACHE_IMAGE; then

          # If that didnt work try the latest dev image from develop
          CACHE_IMAGE="$RELEASE_IMAGE_REPO/$DEV_IMAGE_NAME:$DEVELOP_LATEST_TAG";
          if ! docker pull $CACHE_IMAGE; then
             CACHE_IMAGE=""
          fi
      fi

      EXTRA_BUILD_ARGS=""
      if [[ -n "$CACHE_IMAGE" ]]; then
        echo "Caching docker build from $CACHE_IMAGE";
        EXTRA_BUILD_ARGS="$EXTRA_BUILD_ARGS --cache-from $CACHE_IMAGE";
      else
        echo "Couldn't find image to cache build using"
      fi

      # This image tag is one that can be used by subsequent build steps, using the
      # latest one might introduce race conditions with concurrent pipelines. Instead
      # by using a simple name + sha we know we will be getting the right image later on
      # and we can easily re-construct this image path also as $CI_COMMIT_SHORT_SHA is
      # available in all stages.
      CI_IMAGE_PATH=$CI_IMAGE_REPO/$DEV_IMAGE_NAME:$CLEANUP_JOB_CI_TAG_PREFIX$CI_COMMIT_SHORT_SHA

      # ===== 2. Build a dev image to be used in subsequent CI stages =====

      if [[ -n "$BUILD_FROM_IMAGE" ]]; then
        EXTRA_BUILD_ARGS="$EXTRA_BUILD_ARGS --build-arg FROM_IMAGE=$BUILD_FROM_IMAGE";
        echo "Building from $BUILD_FROM_IMAGE."
      fi

      # * Use `--build-arg BUILDKIT_INLINE_CACHE=1` to ensure this image's itermediate
      #    layers will be cached so builds caching from this image can use those layers.
      # * $CACHE_ARG is a --cache-from if we have an existing image that we can use
      #    to speed up this build.
      # * Target the dev image as we want to run tests and linting in this image.
      # * Tag as both the ci image for use in later stages and the latest ci image to
      #   cache any future ci pipeline runs.
      docker build \
        --build-arg BUILDKIT_INLINE_CACHE=1 \
        $EXTRA_BUILD_ARGS \
        $IMAGE_LABELS \
        --target dev \
        --tag $CI_IMAGE_PATH \
        --tag $LATEST_CI_IMAGE \
        -f $DOCKERFILE_PATH .;

      # ===== 3. Push the CI image for the next stages and latest ci image cache =====

      docker push $CI_IMAGE_PATH
      docker push $LATEST_CI_IMAGE

# Builds a non-dev (no docker build target provided) and fully labelled final image
# and tags and pushes the non-dev and dev images using $TESTED_IMAGE_PREFIX to mark
# them as being successfully tested for the publishing jobs to use.
#
# To extend this stage set the DOCKERFILE_PATH, IMAGE_NAME and DEV_IMAGE_NAME variables.
.build-final-baserow-image:
  image: $CI_UTIL_IMAGE
  stage: build-final
  interruptible: true
  # We can't use the newer rules: syntax due to https://gitlab.com/gitlab-org/gitlab/-/issues/34756
  except:
    refs:
      # When a pipeline is triggered by an upstream project we don't want to rebuild.
      - pipelines
      # When a pipeline is triggered by a git commit tag we don't want to rebuild.
      - tags
  services:
    - docker:20.10.12-dind
  variables:
    DOCKER_BUILDKIT: 1
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
    IMAGE_LABELS: >
      --label org.opencontainers.image.vendor=$CI_PROJECT_URL
      --label org.opencontainers.image.authors=$CI_PROJECT_URL
      --label org.opencontainers.image.revision=$CI_COMMIT_SHA
      --label org.opencontainers.image.source=$CI_PROJECT_URL
      --label org.opencontainers.image.documentation=$CI_PROJECT_URL
      --label org.opencontainers.image.licenses=$CI_PROJECT_URL
      --label org.opencontainers.image.url=$CI_PROJECT_URL
      --label vcs-url=$CI_PROJECT_URL
      --label com.gitlab.ci.user=$CI_SERVER_URL/$GITLAB_USER_LOGIN
      --label com.gitlab.ci.email=$GITLAB_USER_EMAIL
      --label com.gitlab.ci.tagorbranch=$CI_COMMIT_REF_NAME
      --label com.gitlab.ci.pipelineurl=$CI_PIPELINE_URL
      --label com.gitlab.ci.commiturl=$CI_PROJECT_URL/commit/$CI_COMMIT_SHA
      --label com.gitlab.ci.cijoburl=$CI_JOB_URL
      --label com.gitlab.ci.mrurl=$CI_PROJECT_URL/-/merge_requests/$CI_MERGE_REQUEST_ID
      --label org.opencontainers.image.ref.name=$RELEASE_IMAGE_REPO:$CI_COMMIT_REF_NAME
  script:
    - |
      echo "$CI_REGISTRY_PASSWORD" | \
        docker login -u "$CI_REGISTRY_USER" "$CI_REGISTRY" --password-stdin
      if [[ -z "$DOCKERFILE_PATH" ]]; then
          echo "Must provide DOCKERFILE_PATH as a job variable" 2>&1
          exit 1
      fi
      if [[ -z "$IMAGE_NAME" ]]; then
          echo "Must provide IMAGE_NAME as a job variable" 2>&1
          exit 1
      fi
      if [[ -z "$DEV_IMAGE_NAME" ]]; then
          echo "Must provide DEV_IMAGE_NAME as a job variable" 2>&1
          exit 1
      fi

      # ===== 1. Setup image metadata labels =====
      #Build date for opencontainers
      #rfc 3339 date
      BUILDDATE="'$(date '+%FT%T%z' | sed -E -n 's/(\+[0-9]{2})([0-9]{2})$/\1:\2/p')'"
      IMAGE_LABELS="$IMAGE_LABELS --label org.opencontainers.image.created=$BUILDDATE"
      IMAGE_LABELS="$IMAGE_LABELS --label build-date=$BUILDDATE"
      # Description for opencontainers
      BUILDTITLE="$(echo $CI_PROJECT_TITLE | tr " " "_")_$IMAGE_NAME"
      IMAGE_LABELS="$IMAGE_LABELS --label org.opencontainers.image.title=$BUILDTITLE"
      IMAGE_LABELS="$IMAGE_LABELS --label org.opencontainers.image.description=$BUILDTITLE"

      # ==== 2. Tag, build and push non-dev image ====

      # Cache from the CI dev image to build the non dev image.
      CI_IMAGE_PATH=$CI_IMAGE_REPO/$DEV_IMAGE_NAME:$CLEANUP_JOB_CI_TAG_PREFIX$CI_COMMIT_SHORT_SHA

      TRUNCATED_BRANCH_NAME=${CI_COMMIT_REF_NAME:0:100}
      NON_DEV_CACHE_IMAGE=$CI_IMAGE_REPO/$IMAGE_NAME:$CLEANUP_JOB_CI_TAG_PREFIX$TRUNCATED_BRANCH_NAME

      TARGET_NON_DEV_IMAGE_PATH=$CI_IMAGE_REPO/$IMAGE_NAME:$TESTED_IMAGE_PREFIX$CI_COMMIT_SHORT_SHA
      TARGET_DEV_IMAGE_PATH=$CI_IMAGE_REPO/$DEV_IMAGE_NAME:$TESTED_IMAGE_PREFIX$CI_COMMIT_SHORT_SHA

      docker pull $CI_IMAGE_PATH

      if ! docker pull $NON_DEV_CACHE_IMAGE ; then
        echo "Failed to find non dev cache image $NON_DEV_CACHE_IMAGE..."
        EXTRA_BUILD_ARGS="";
      else
        echo "Caching from $NON_DEV_CACHE_IMAGE";
        EXTRA_BUILD_ARGS="--cache-from $NON_DEV_CACHE_IMAGE";
      fi
      
      if [[ -n "$BUILD_FROM_IMAGE" ]]; then
        EXTRA_BUILD_ARGS="$EXTRA_BUILD_ARGS --build-arg FROM_IMAGE=$BUILD_FROM_IMAGE";
        IMAGE_LABELS="$IMAGE_LABELS --label built-from-image=$BUILD_FROM_IMAGE"
        if docker pull "$BUILD_FROM_IMAGE"; then
          BUILT_FROM_REVISION=$(docker inspect $BUILD_FROM_IMAGE | jq -r '.[0].Config.Labels["org.opencontainers.image.revision"]')
          BUILT_FROM_COMMITURL=$(docker inspect $BUILD_FROM_IMAGE | jq -r '.[0].Config.Labels["com.gitlab.ci.commiturl"]')
          BUILT_FROM_CIJOBURL=$(docker inspect $BUILD_FROM_IMAGE | jq -r '.[0].Config.Labels["com.gitlab.ci.cijoburl"]')
          BUILT_FROM_MRURL=$(docker inspect $BUILD_FROM_IMAGE | jq -r '.[0].Config.Labels["com.gitlab.ci.mrurl"]')
          BUILT_FROM_VCSURL=$(docker inspect $BUILD_FROM_IMAGE | jq -r '.[0].Config.Labels["vcs-url"]')

          IMAGE_LABELS="$IMAGE_LABELS --label built-from-revision=$BUILD_FROM_REVISION"
          IMAGE_LABELS="$IMAGE_LABELS --label built-from-commiturl=$BUILD_FROM_COMMITURL"
          IMAGE_LABELS="$IMAGE_LABELS --label built-from-cijoburl=$BUILD_FROM_CIJOBURL"
          IMAGE_LABELS="$IMAGE_LABELS --label built-from-mrurl=$BUILD_FROM_MRURL"
          IMAGE_LABELS="$IMAGE_LABELS --label built-from-vcsurl=$BUILD_FROM_VCSURL"
        else
          echo "Failed to pull build from image $BUILD_FROM_IMAGE, something has gone wrong"
          exit 1
        fi
      fi

      # Build the normal non-dev image with all the tags and labels.
      docker build \
        --cache-from $CI_IMAGE_PATH \
        $EXTRA_BUILD_ARGS \
        $FORMATTEDTAGLIST \
        $IMAGE_LABELS \
        -t $TARGET_NON_DEV_IMAGE_PATH \
        -f $DOCKERFILE_PATH .;
      docker push $TARGET_NON_DEV_IMAGE_PATH

      # Build the cache image with layer caching enabled. We don't enable it for the image above to reduce its size.
      docker build \
        --cache-from $CI_IMAGE_PATH \
        $EXTRA_BUILD_ARGS \
        $IMAGE_LABELS \
        --build-arg BUILDKIT_INLINE_CACHE=1 \
        -t $NON_DEV_CACHE_IMAGE \
        -f $DOCKERFILE_PATH .;
      docker push $NON_DEV_CACHE_IMAGE

      docker tag $CI_IMAGE_PATH $TARGET_DEV_IMAGE_PATH
      docker push $TARGET_DEV_IMAGE_PATH

# A simple docker based test job which does not run for a TAG pipeline and does not
# check out git.
.docker-image-test-stage:
  stage: test
  image: $CI_UTIL_IMAGE
  interruptible: true
  # We can't use the newer rules: syntax due to https://gitlab.com/gitlab-org/gitlab/-/issues/34756
  except:
    refs:
      # When a pipeline is triggered by an upstream project we don't want to retest.
      - pipelines
      # When a pipeline is triggered by a git commit tag we don't want to retest.
      - tags
  services:
    - docker:20.10.12-dind


.skippable-job:
  before_script:
    - |
      CLEAR="\e[0m"
      RED="\e[31m"
      GREEN="\e[32m"

      echo -e "$GREEN =========== JOB SKIPPER =========== $CLEAR"
      if [[ -z "$RUN_WHEN_CHANGES_TO" ]]; then
          echo "Must provide RUN_WHEN_CHANGES_TO as a job variable" 2>&1
          exit 1
      fi

      if [[ "$ENABLE_JOB_SKIPPING" = "true" ]]; then

        exit_with_copied_artifacts_if_successful_job_for_commit(){
          COMMIT_HASH=$1
          JOB_NAME=$2
          URL="https://gitlab.com/api/v4/projects/$CI_PROJECT_ID/repository/commits/$COMMIT_HASH/statuses?name=$JOB_NAME"
          COMMIT_GITLAB_JOBS=$(curl --header "PRIVATE-TOKEN: $PROJECT_READ_ONLY_API_TOKEN" $URL)

          if [[ "$COMMIT_GITLAB_JOBS" ]]; then
            echo -e "\e[0Ksection_start:`date +%s`:$COMMIT_HASH$JOB_NAME[collapsed=true]\r\e[0KRaw job status download for $JOB_NAME and $COMMIT_HASH"
            echo "Got these job statuses: $COMMIT_GITLAB_JOBS"
            JOB_ID=$(echo $COMMIT_GITLAB_JOBS| jq "[.[] | select(.status == \"success\")][0].id")
            echo -e "\e[0Ksection_end:`date +%s`:$COMMIT_HASH$JOB_NAME\r\e[0K"
            # Check if JOB_ID is an integer (POSIX compliant way)

            # Check if JOB_ID is an integer using bash magic.
            if [ "$JOB_ID" -eq "$JOB_ID" ] 2> /dev/null;  then
              if [[ -n "$DOWNLOAD_AND_UNPACK_ARTIFACTS_ON_SKIP" ]] ; then
                exit_code=0
                curl --fail --location --output artifacts.zip \
                  --header "PRIVATE-TOKEN: $PROJECT_READ_ONLY_API_TOKEN" \
                  "https://gitlab.com/api/v4/projects/$CI_PROJECT_ID/jobs/$JOB_ID/artifacts" \
                  || exit_code=$?;

                if [ ${exit_code} -ne 0 ]; then
                  echo -e "$RED Failed to get artifacts from successful run $JOB_ID $CLEAR"
                else
                  unzip artifacts.zip || exit_code=$?
                  if [ ${exit_code} -ne 0 ]; then
                    echo -e "$RED Failed to unzip artifacts $CLEAR"
                  else
                    # Echo a stdout report if found so gitlab's coverage regex which
                    # searches stdout to find the overall coverage is correct even for
                    # skipped jobs.
                    if [[ -f "reports/stdout.txt" ]]; then
                        cat reports/stdout.txt;
                    fi
                    echo -e "$GREEN Skipping $JOB_NAME as previous successful run for $COMMIT_HASH and it's artifacts were found. $CLEAR"
                    exit 0;
                  fi
                fi

              else
                echo -e "$GREEN Skipping $JOB_NAME as previous successful build for $COMMIT_HASH was found. $CLEAR".
                exit 0;
              fi
            else
              echo "Failed to find successful run of $JOB_NAME in job statuses from gitlab for commit $COMMIT_HASH."
            fi
          else
            echo -e "$RED Failed to query gitlab for jobs $CLEAR";
          fi
        }

        echo "Checking if we can skip immediately if this commit already has a successful job run..."
        exit_with_copied_artifacts_if_successful_job_for_commit $CI_COMMIT_SHA $CI_JOB_NAME
        echo "Can't immediately skip as there was no successful previous job for this commit, checking changes..."

        CHANGED_FILES=$(git diff --name-only --diff-filter=ADMR @~..@)
        grep_exit_code=0
        found_changes=0
        for SEARCH_PATTERN in $RUN_WHEN_CHANGES_TO; do
            echo $CHANGED_FILES | grep -q $SEARCH_PATTERN || grep_exit_code=$?;
            if [ ${grep_exit_code} -eq 0 ]; then
              echo -e "Found changes matching $GREEN $SEARCH_PATTERN $CLEAR in:"
              echo $CHANGED_FILES
              echo -e "$GREEN Running job normally without skipping due to the changes. $CLEAR"
              found_changes=1
              break
            fi
        done

        if [ ${found_changes} -eq 0 ]; then
          echo "No git diff changes found matching $RUN_WHEN_CHANGES_TO."
          echo "Checking for previous commits job..."
          SECOND_PARENT_COMMIT=$(git rev-list -1 --merges ${CI_COMMIT_SHA}~1..${CI_COMMIT_SHA})
          if [[ -z "$SECOND_PARENT_COMMIT" ]] ; then
            # If there is no second parent commit then there is only one parent commit
            # and so we can safely check to see if that parent commit has a successful
            # job run as this commit does not change any relavent files.
            PREVIOUS_COMMIT_SHA=$(git rev-parse HEAD~1)
            echo "Found single previous commit $PREVIOUS_COMMIT_SHA, checking for job.."
            exit_with_copied_artifacts_if_successful_job_for_commit $PREVIOUS_COMMIT_SHA $CI_JOB_NAME
            echo -e "$GREEN Running job without skipping as successful run for previous or this commit not found $CLEAR"
          else
            # There are more than one parent commits meaning we should re-run this job
            # as this commit is a merge commit with multiple parents, so we can't safely
            # skip this job.
            echo -e "$GREEN Running full job as this is a merge commit. $CLEAR"
          fi
        fi
      else
          echo -e "$GREEN Force running job regardless of previous runs. $CLEAR"
      fi

      echo -e "$GREEN ================================ $CLEAR"
